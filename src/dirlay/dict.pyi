from collections import UserDict
from collections.abc import ItemsView, Iterable, Iterator
from typing import Any, Dict, Generic, Optional, Tuple, Type, TypeVar, Union

from typing_extensions import TypeAlias

D = TypeVar('D', bound=dict[str, Any])
StrDict: TypeAlias = Dict[str, Any]
AnyDict: TypeAlias = Union[StrDict, UserDict[str, Any]]

class NestedDict(UserDict[str, Any], Generic[D]):
    dict_class: Type[D]
    data: D
    sep: str
    _len: int
    def __init__(self, dict: Optional[StrDict] = None, /, *, sep: str = ...): ...
    def __eq__(self, other: Any) -> bool: ...
    def __len__(self) -> int: ...
    def __getitem__(self, key: str) -> Any: ...
    def __setitem__(self, key: str, item: Any) -> None: ...
    def __delitem__(self, key: str) -> None: ...
    def _count(self, item: Any) -> int: ...
    def _traverse(
        self,
        key: str,
        create_parents: bool,
        base: StrDict,
    ) -> Tuple[StrDict, str]: ...
    def _update(self, other: StrDict, base: StrDict) -> None: ...
    def __iter__(self) -> Iterator[str]: ...
    def items(self) -> ItemsView[str, Any]: ...
    def _walk(
        self,
        entries: StrDict,
        prefix: Optional[str] = ...,
    ) -> Iterable[Tuple[str, Any]]: ...
    def __contains__(self, key: object) -> bool: ...
    def get(self, key: str, default: Any = ...) -> Any: ...
    def __repr__(self) -> str: ...
    def __or__(self, other: AnyDict) -> 'NestedDict': ...  # type: ignore
    def __ror__(self, other: AnyDict) -> 'NestedDict': ...  # type: ignore
    def __ior__(self, other: AnyDict) -> 'NestedDict': ...  # type: ignore
    @staticmethod
    def _operand(other: AnyDict) -> StrDict: ...
    def __copy__(self) -> 'NestedDict[D]': ...
    def clear(self) -> None: ...
    def copy(self) -> 'NestedDict[D]': ...
    @classmethod
    def fromkeys(cls, iterable: Iterable[str], value: Any = ...) -> 'NestedDict[D]': ...  # type: ignore
